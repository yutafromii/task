🔼 フェーズ1：ログイン機能の実用化（最低限のプロダクションレベル）
① JWTの保存と自動送信

    ✅ 今：トークンを返却のみで保存していない

    🛠 改善：ブラウザにトークンを保存（Cookie or LocalStorage）

        Cookieに保存するならhttpOnly=true + Secure属性で保護

        Authorization: Bearer <token> 形式でAPIに送信

② 認証付きAPIの作成

    /api/user/me など、ログインユーザーだけがアクセスできるAPIを実装

    @GetMapping("/me") で SecurityContext からユーザー情報を取得

③ フロント側の状態管理

    ログイン状態の保持（グローバル状態管理：ZustandやContext API）

    ログインしていなければ /login にリダイレクトなど

🔼 フェーズ2：認可（Authorization）とユーザー管理
① ユーザーロールの導入

    管理者・一般ユーザーなどの役割（ROLE_ADMIN, ROLE_USER）をJWTに含める

    Spring Securityの .hasRole("ADMIN") などでAPI制限

② ユーザー登録（Sign Up）機能

    フロントにサインアップフォームを追加

    Spring Bootに新規ユーザー登録API（DB保存）を実装

    パスワードはBCryptでハッシュ化

③ ログアウト機能

    Cookie削除やトークンの削除処理を追加

🔼 フェーズ3：セキュリティ強化
① トークンの有効期限・リフレッシュ

    JWTの有効期限を短く設定（例：15分）

    リフレッシュトークンの仕組みを導入（DB保存 or Cookie）

② CORS制御の本番対応

    開発中は@CrossOrigin("*")だが、本番では許可ドメインを制限

③ CSRF対応（場合により）

    Cookie利用時など、セッション管理と合わせて検討

🔼 フェーズ4：実サービス化への統合設計
① CI/CD導入（GitHub Actions / GitLab CI など）

    フロントとバックのビルド・デプロイを自動化

② 環境変数の導入

    JWT秘密鍵、DB接続情報などを .env で安全に管理

③ HTTPS対応・ドメイン取得

    Cloudflare + Vercel or RenderなどでSSLつき公開






  @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody Map<String, String> user) {
        try {
            if ("testuser".equals(user.get("username")) && "password".equals(user.get("password"))) {
                String token = jwtUtil.generateToken(user.get("username"));
                logger.info("ログイン成功: {}", user.get("username"));
                return ResponseEntity.ok(Collections.singletonMap("token", token));
            } else {
                logger.warn("認証失敗: {}", user.get("username"));
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("ログインに失敗しました");
            }
        } catch (Exception e) {
            logger.error("ログイン処理中に例外が発生", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("サーバーエラー");
        }
    }